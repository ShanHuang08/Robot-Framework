from playwright.sync_api import sync_playwright, Page, expect
from time import time, sleep
import logging

class Playwright_Funs():
    def __init__(self, headless=True, timeout=30000):
        """
        Generated by Claude on 2025/08/29
        初始化 Playwright
        
        Args:
            headless (bool): 是否使用無頭模式
            timeout (int): 預設等待時間（毫秒）
        """
        self.playwright = sync_playwright().start()
        self.headless = headless
        self.timeout = timeout
        self.page = None
        
        # 設定日誌
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    def launch_browser(self, browser_type='chromium'):
        try:
            if browser_type == 'firefox':
                self.browser = self.playwright.firefox.launch(headless=self.headless)
            elif browser_type == 'webkit':
                self.browser = self.playwright.webkit.launch(headless=self.headless)
            else:
                self.browser = self.playwright.chromium.launch(headless=self.headless)
            
            self.logger.info(f"已啟動 {browser_type} 瀏覽器")
            return self.browser
        except Exception as e:
            self.logger.error(f"啟動瀏覽器失敗: {e}")
            raise


    def create_page(self, url=None, mobile=False, device_name=None):
        """
        創建新頁面
        
        Args:
            url (str): 要導航的 URL
            mobile (bool): 是否使用行動裝置模式
            device_name (str): 裝置名稱（如 'iPhone 12'）
        """
        if not self.browser:
            self.launch_browser()
        
        try:
            if device_name:
                # 使用 Playwright 內建的裝置設定
                device = self.playwright.devices[device_name]
                self.page = self.browser.new_page(**device)
            elif mobile:
                # 自訂行動裝置設定
                viewport = {'width': 414, 'height': 896}
                user_agent = "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1"
                self.page = self.browser.new_page(
                    viewport=viewport, 
                    user_agent=user_agent
                )
            else:
                self.page = self.browser.new_page()
            
            # 設定預設等待時間
            self.page.set_default_timeout(self.timeout)
            
            if url:
                self.navigate_to(url)
                
            self.logger.info("已創建新頁面")
            return self.page
            
        except Exception as e:
            self.logger.error(f"創建頁面失敗: {e}")
            raise

    def navigate_to(self, url):
        """導航到指定 URL"""
        if not self.page:
            raise Exception("請先創建頁面")
        
        try:
            self.page.goto(url)
            self.logger.info(f"已導航到: {url}")
        except Exception as e:
            self.logger.error(f"導航失敗: {e}")
            raise

    def wait_for_element(self, selector, timeout=None):
        """等待元素出現"""
        if not timeout:
            timeout = self.timeout
            
        try:
            self.page.wait_for_selector(selector, timeout=timeout)
            return True
        except Exception as e:
            self.logger.warning(f"等待元素 {selector} 超時: {e}")
            return False

    def click_element(self, selector, wait=True):
        """
        點擊元素
        
        Args:
            selector (str): CSS 選擇器
            wait (bool): 是否等待元素出現
        """
        if not self.page:
            raise Exception("請先創建頁面")
        
        try:
            if wait:
                self.wait_for_element(selector)
            self.page.click(selector)
            self.logger.info(f"已點擊元素: {selector}")
        except Exception as e:
            self.logger.error(f"點擊元素 {selector} 失敗: {e}")
            raise

    def type_text(self, selector, text, clear=True, wait=True):
        """
        輸入文字
        
        Args:
            selector (str): CSS 選擇器
            text (str): 要輸入的文字
            clear (bool): 是否先清空內容
            wait (bool): 是否等待元素出現
        """
        if not self.page:
            raise Exception("請先創建頁面")
            
        try:
            if wait:
                self.wait_for_element(selector)
                
            if clear:
                self.page.fill(selector, text)
            else:
                self.page.type(selector, text)
                
            self.logger.info(f"已在 {selector} 輸入文字")
        except Exception as e:
            self.logger.error(f"輸入文字到 {selector} 失敗: {e}")
            raise

    def get_text(self, selector, wait=True):
        """獲取元素文字內容"""
        if not self.page:
            raise Exception("請先創建頁面")
            
        try:
            if wait:
                self.wait_for_element(selector)
            return self.page.text_content(selector)
        except Exception as e:
            self.logger.error(f"獲取 {selector} 文字失敗: {e}")
            return None

    def get_attribute(self, selector, attribute, wait=True):
        """獲取元素屬性值"""
        if not self.page:
            raise Exception("請先創建頁面")
            
        try:
            if wait:
                self.wait_for_element(selector)
            return self.page.get_attribute(selector, attribute)
        except Exception as e:
            self.logger.error(f"獲取 {selector} 的 {attribute} 屬性失敗: {e}")
            return None

    def scroll_to_element(self, selector, wait=True):
        """滾動到元素"""
        if not self.page:
            raise Exception("請先創建頁面")
            
        try:
            if wait:
                self.wait_for_element(selector)
            self.page.locator(selector).scroll_into_view_if_needed()
            self.page.wait_for_timeout(500)  # 減少等待時間
            self.logger.info(f"已滾動到元素: {selector}")
        except Exception as e:
            self.logger.error(f"滾動到 {selector} 失敗: {e}")
            raise

    def take_screenshot(self, path=None, full_page=False):
        """截圖"""
        if not self.page:
            raise Exception("請先創建頁面")
            
        try:
            if not path:
                path = f"screenshot_{int(time.time())}.png"
            
            self.page.screenshot(path=path, full_page=full_page)
            self.logger.info(f"已截圖: {path}")
            return path
        except Exception as e:
            self.logger.error(f"截圖失敗: {e}")
            raise

    def wait(self, seconds):
        """暫停等待"""
        sleep(seconds)
        self.logger.info(f"等待 {seconds} 秒")

    def close(self):
        """關閉瀏覽器和 Playwright"""
        try:
            if self.page:
                self.page.close()
            if self.browser:
                self.browser.close()
            if self.playwright:
                self.playwright.stop()
            self.logger.info("已關閉 Playwright")
        except Exception as e:
            self.logger.error(f"關閉失敗: {e}")

    def __enter__(self):
        """支援 with 語法"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """自動關閉資源"""
        self.close()


# 使用範例
if __name__ == "__main__":
    # 使用 with 語法自動管理資源
    with Playwright_Funs(headless=False) as pw:
        # 創建桌面頁面
        page = pw.create_page("https://example.com")
        
        # 創建行動裝置頁面
        # page = pw.create_page("https://example.com", device_name="iPhone 12")
        
        # 基本操作
        pw.click_element("button#submit")
        pw.type_text("input[name='username']", "test_user")
        text = pw.get_text("h1")
        print(f"頁面標題: {text}")
        
        # 截圖
        pw.take_screenshot("example.png")
        
        pw.wait(2)